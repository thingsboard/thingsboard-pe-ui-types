import { AfterViewInit, ChangeDetectorRef, OnInit } from '@angular/core';
import { TbPopoverComponent } from '@shared/components/popover.component';
import { AbstractControl, FormBuilder, FormControl, FormGroup, UntypedFormArray } from '@angular/forms';
import { ArgumentEntityType, CalculatedFieldGeofencing, CalculatedFieldGeofencingValue, CalculatedFieldType, GeofencingReportStrategy } from '@shared/models/calculated-field.models';
import { AttributeScope, DataKeyType } from '@shared/models/telemetry/telemetry.models';
import { EntityId } from '@shared/models/id/entity-id';
import { EntityFilter } from '@shared/models/query/query.models';
import { BehaviorSubject, Observable } from 'rxjs';
import { AppState } from '@core/core.state';
import { Store } from '@ngrx/store';
import { EntityAutocompleteComponent } from '@shared/components/entity/entity-autocomplete.component';
import { EntitySearchDirection } from '@shared/models/relation.models';
import { CdkDragDrop } from "@angular/cdk/drag-drop";
import * as i0 from "@angular/core";
export declare class CalculatedFieldGeofencingZoneGroupsPanelComponent implements OnInit, AfterViewInit {
    private fb;
    private cd;
    private popover;
    private store;
    buttonTitle: string;
    zone: CalculatedFieldGeofencing;
    entityId: EntityId;
    tenantId: string;
    entityName: string;
    ownerId: EntityId;
    calculatedFieldType: CalculatedFieldType;
    usedNames: string[];
    readonly: boolean;
    entityAutocomplete: EntityAutocompleteComponent;
    geofencingDataApplied: import("@angular/core").OutputEmitterRef<CalculatedFieldGeofencingValue>;
    readonly maxRelationLevelPerCfArgument: number;
    geofencingFormGroup: FormGroup<{
        name: FormControl<string>;
        refEntityId: FormGroup<{
            entityType: FormControl<ArgumentEntityType>;
            id: FormControl<string>;
        }>;
        refDynamicSourceConfiguration: FormGroup<{
            levels: import("@angular/forms").FormArray<FormControl<unknown>>;
        }>;
        perimeterKeyName: FormControl<string>;
        reportStrategy: FormControl<GeofencingReportStrategy>;
        createRelationsWithMatchedZones: FormControl<boolean>;
        direction: FormControl<EntitySearchDirection>;
        relationType: FormControl<string>;
    }>;
    entityFilter: EntityFilter;
    entityNameSubject: BehaviorSubject<string>;
    enableAutocomplete: boolean;
    readonly ArgumentEntityType: typeof ArgumentEntityType;
    readonly argumentEntityTypes: ArgumentEntityType[];
    readonly ArgumentEntityTypeTranslations: Map<ArgumentEntityType, string>;
    readonly DataKeyType: typeof DataKeyType;
    readonly ArgumentEntityTypeParamsMap: Map<ArgumentEntityType, import("@shared/models/calculated-field.models").ArgumentEntityTypeParams>;
    readonly GeofencingReportStrategyList: Array<GeofencingReportStrategy>;
    readonly GeofencingReportStrategyTranslations: Map<GeofencingReportStrategy, string>;
    readonly GeofencingDirectionList: Array<EntitySearchDirection>;
    readonly GeofencingDirectionTranslations: Map<EntitySearchDirection, string>;
    readonly GeofencingDirectionLevelTranslations: Map<EntitySearchDirection, string>;
    readonly AttributeScope: typeof AttributeScope;
    private currentEntityFilter;
    constructor(fb: FormBuilder, cd: ChangeDetectorRef, popover: TbPopoverComponent<CalculatedFieldGeofencingZoneGroupsPanelComponent>, store: Store<AppState>);
    get entityType(): ArgumentEntityType;
    get refEntityIdFormGroup(): FormGroup;
    get refDynamicSourceFormGroup(): FormGroup;
    ngOnInit(): void;
    fetchOptions(searchText: string): Observable<Array<string>>;
    private updatedFormValidators;
    private observeCreateRelationZonesChanges;
    private validateDirectionAndRelationType;
    private validateRefDynamicSourceConfiguration;
    ngAfterViewInit(): void;
    saveZone(): void;
    cancel(): void;
    private updateEntityFilter;
    private observeEntityFilterChanges;
    private observeEntityTypeChanges;
    private levelsRequired;
    levelsFormArray(): UntypedFormArray;
    trackByKey(_index: number, keyControl: AbstractControl): any;
    removeKey(index: number): void;
    addKey(): void;
    keyDrop(event: CdkDragDrop<string[]>): void;
    get dragEnabled(): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<CalculatedFieldGeofencingZoneGroupsPanelComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CalculatedFieldGeofencingZoneGroupsPanelComponent, "tb-calculated-field-geofencing-zone-groups-panel", never, { "buttonTitle": { "alias": "buttonTitle"; "required": false; }; "zone": { "alias": "zone"; "required": false; }; "entityId": { "alias": "entityId"; "required": false; }; "tenantId": { "alias": "tenantId"; "required": false; }; "entityName": { "alias": "entityName"; "required": false; }; "ownerId": { "alias": "ownerId"; "required": false; }; "calculatedFieldType": { "alias": "calculatedFieldType"; "required": false; }; "usedNames": { "alias": "usedNames"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; }, { "geofencingDataApplied": "geofencingDataApplied"; }, never, never, false, never>;
}
