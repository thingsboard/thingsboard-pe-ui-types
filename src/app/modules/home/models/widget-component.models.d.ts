import { IDashboardComponent } from '@home/models/dashboard-component.models';
import { DataSet, Datasource, DatasourceData, FormattedData, Widget, WidgetActionDescriptor, WidgetActionSource, WidgetConfig, WidgetControllerDescriptor, WidgetExportType, WidgetHeaderActionButtonType, WidgetType, widgetType, WidgetTypeDescriptor, WidgetTypeDetails, WidgetTypeParameters } from '@shared/models/widget.models';
import { Timewindow, WidgetTimewindow } from '@shared/models/time/time.models';
import { IAliasController, IStateController, IWidgetSubscription, IWidgetUtils, RpcApi, StateParams, SubscriptionEntityInfo, TimewindowFunctions, WidgetActionsApi, WidgetSubscriptionApi } from '@core/api/widget-api.models';
import { ChangeDetectorRef, InjectionToken, Injector, NgZone, Renderer2, TemplateRef, Type, ViewContainerRef } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { RafService } from '@core/services/raf.service';
import { WidgetTypeId } from '@shared/models/id/widget-type-id';
import { TenantId } from '@shared/models/id/tenant-id';
import { WidgetLayout } from '@shared/models/dashboard.models';
import { Store } from '@ngrx/store';
import { AppState } from '@core/core.state';
import { NotificationHorizontalPosition, NotificationType, NotificationVerticalPosition } from '@core/notification/notification.models';
import { AuthUser } from '@shared/models/user.model';
import { DeviceService } from '@core/http/device.service';
import { AssetService } from '@core/http/asset.service';
import { EntityViewService } from '@core/http/entity-view.service';
import { CustomerService } from '@core/http/customer.service';
import { DashboardService } from '@core/http/dashboard.service';
import { UserService } from '@core/http/user.service';
import { AttributeService } from '@core/http/attribute.service';
import { EntityRelationService } from '@core/http/entity-relation.service';
import { EntityService } from '@core/http/entity.service';
import { DialogService } from '@core/services/dialog.service';
import { CustomDialogService } from '@home/components/widget/dialog/custom-dialog.service';
import { AuthService } from '@core/auth/auth.service';
import { ResourceService } from '@core/http/resource.service';
import { TelemetryWebsocketService } from '@core/ws/telemetry-websocket.service';
import { DatePipe } from '@angular/common';
import { TranslateService } from '@ngx-translate/core';
import { EntityGroupService } from '@core/http/entity-group.service';
import { PageLink, TimePageLink } from '@shared/models/page/page-link';
import { SortOrder } from '@shared/models/page/sort-order';
import { DomSanitizer } from '@angular/platform-browser';
import { Router } from '@angular/router';
import { EdgeService } from '@core/http/edge.service';
import * as RxJS from 'rxjs';
import { Observable } from 'rxjs';
import * as RxJSOperators from 'rxjs/operators';
import { TbPopoverComponent } from '@shared/components/popover.component';
import { EntityId } from '@shared/models/id/entity-id';
import { DashboardReportService } from '@core/http/dashboard-report.service';
import { AlarmQuery, AlarmSearchStatus, AlarmStatus } from '@app/shared/models/alarm.models';
import { ImagePipe } from '@shared/pipe/image.pipe';
import { MillisecondsToTimeStringPipe } from '@shared/pipe/milliseconds-to-time-string.pipe';
import { SharedTelemetrySubscriber, TelemetrySubscriber } from '@shared/models/telemetry/telemetry.models';
import { UserId } from '@shared/models/id/user-id';
import { UserSettingsService } from '@core/http/user-settings.service';
import { WhiteLabelingService } from '@core/http/white-labeling.service';
import { DataKeySettingsFunction } from '@home/components/widget/lib/settings/common/key/data-keys.component.models';
import { UtilsService } from '@core/services/utils.service';
import { CompiledTbFunction } from '@shared/models/js-function.models';
import { FormProperty } from '@shared/models/dynamic-form.models';
import { ExportableEntity } from '@shared/models/base-data';
import { TbUnit } from '@shared/models/unit.models';
import { UnitService } from '@core/services/unit.service';
export interface IWidgetAction {
    name: string;
    icon: string;
    onAction: ($event: Event) => void;
}
export type ShowWidgetHeaderActionFunction = (ctx: WidgetContext, data: FormattedData[]) => boolean;
export interface WidgetHeaderAction extends IWidgetAction {
    displayName: string;
    descriptor: WidgetActionDescriptor;
    buttonType?: WidgetHeaderActionButtonType;
    showIcon?: boolean;
    buttonColor?: string;
    buttonFillColor?: string;
    buttonBorderColor?: string;
    customButtonStyle?: {
        [key: string]: string;
    };
    useShowWidgetHeaderActionFunction: boolean;
    showWidgetHeaderActionFunction: CompiledTbFunction<ShowWidgetHeaderActionFunction>;
}
export interface WidgetAction extends IWidgetAction {
    show: boolean;
}
export interface IDashboardWidget {
    updateWidgetParams(): void;
}
export declare class WidgetContext {
    dashboard: IDashboardComponent;
    private dashboardWidget;
    private widget;
    parentDashboard?: IDashboardComponent;
    popoverComponent?: TbPopoverComponent;
    constructor(dashboard: IDashboardComponent, dashboardWidget: IDashboardWidget, widget: Widget, parentDashboard?: IDashboardComponent, popoverComponent?: TbPopoverComponent);
    get stateController(): IStateController;
    get aliasController(): IAliasController;
    get dashboardTimewindow(): Timewindow;
    get widgetConfig(): WidgetConfig;
    get settings(): any;
    get units(): TbUnit;
    get decimals(): number;
    set changeDetector(cd: ChangeDetectorRef);
    set containerChangeDetector(cd: ChangeDetectorRef);
    get currentUser(): AuthUser;
    get dashboardPageElement(): HTMLElement;
    get dashboardContentElement(): HTMLElement;
    authService: AuthService;
    deviceService: DeviceService;
    assetService: AssetService;
    entityViewService: EntityViewService;
    edgeService: EdgeService;
    customerService: CustomerService;
    dashboardService: DashboardService;
    userService: UserService;
    attributeService: AttributeService;
    entityRelationService: EntityRelationService;
    entityService: EntityService;
    entityGroupService: EntityGroupService;
    dialogs: DialogService;
    customDialog: CustomDialogService;
    resourceService: ResourceService;
    userSettingsService: UserSettingsService;
    utilsService: UtilsService;
    telemetryWsService: TelemetryWebsocketService;
    unitService: UnitService;
    telemetrySubscribers?: Array<TelemetrySubscriber | SharedTelemetrySubscriber>;
    date: DatePipe;
    imagePipe: ImagePipe;
    milliSecondsToTimeString: MillisecondsToTimeStringPipe;
    translate: TranslateService;
    http: HttpClient;
    sanitizer: DomSanitizer;
    router: Router;
    renderer: Renderer2;
    widgetContentContainer: ViewContainerRef;
    reportService: DashboardReportService;
    wl: WhiteLabelingService;
    private changeDetectorValue;
    private containerChangeDetectorValue;
    inited: boolean;
    destroyed: boolean;
    subscriptions: {
        [id: string]: IWidgetSubscription;
    };
    defaultSubscription: IWidgetSubscription;
    labelPatterns: Map<RxJS.Observable<string>, LabelVariablePattern>;
    timewindowFunctions: TimewindowFunctions;
    controlApi: RpcApi;
    utils: IWidgetUtils;
    $widgetElement: JQuery<HTMLElement>;
    $container: JQuery<HTMLElement>;
    $containerParent: JQuery<HTMLElement>;
    width: number;
    height: number;
    $scope: IDynamicWidgetComponent;
    isEdit: boolean;
    isPreview: boolean;
    isMobile: boolean;
    toastTargetId: string;
    widgetNamespace?: string;
    subscriptionApi?: WidgetSubscriptionApi;
    actionsApi?: WidgetActionsApi;
    activeEntityInfo?: SubscriptionEntityInfo;
    exportWidgetData: (widgetExportType: WidgetExportType) => void;
    customDataExport?: () => {
        [key: string]: any;
    }[] | RxJS.Observable<{
        [key: string]: any;
    }[]>;
    exportDateFormat?: string;
    datasources?: Array<Datasource>;
    data?: Array<DatasourceData>;
    latestData?: Array<DatasourceData>;
    hiddenData?: Array<{
        data: DataSet;
    }>;
    timeWindow?: WidgetTimewindow;
    embedTitlePanel?: boolean;
    embedActionsPanel?: boolean;
    overflowVisible?: boolean;
    hideTitlePanel: boolean;
    widgetTitle?: string;
    widgetTitleTooltip?: string;
    customHeaderActions?: Array<WidgetHeaderAction>;
    widgetActions?: Array<WidgetAction>;
    servicesMap?: Map<string, Type<any>>;
    $injector?: Injector;
    ngZone?: NgZone;
    store?: Store<AppState>;
    private popoverComponents;
    rxjs: {
        audit: typeof RxJS.audit;
        auditTime: typeof RxJS.auditTime;
        buffer: typeof RxJS.buffer;
        bufferCount: typeof RxJS.bufferCount;
        bufferTime: typeof RxJS.bufferTime;
        bufferToggle: typeof RxJS.bufferToggle;
        bufferWhen: typeof RxJS.bufferWhen;
        catchError: typeof RxJS.catchError;
        combineAll: typeof RxJS.combineLatestAll;
        combineLatestAll: typeof RxJS.combineLatestAll;
        combineLatest: typeof RxJSOperators.combineLatest;
        combineLatestWith: typeof RxJS.combineLatestWith;
        concat: typeof RxJSOperators.concat;
        concatAll: typeof RxJS.concatAll;
        concatMap: typeof RxJS.concatMap;
        concatMapTo: typeof RxJS.concatMapTo;
        concatWith: typeof RxJS.concatWith;
        connect: typeof RxJS.connect;
        count: typeof RxJS.count;
        debounce: typeof RxJS.debounce;
        debounceTime: typeof RxJS.debounceTime;
        defaultIfEmpty: typeof RxJS.defaultIfEmpty;
        delay: typeof RxJS.delay;
        delayWhen: typeof RxJS.delayWhen;
        dematerialize: typeof RxJS.dematerialize;
        distinct: typeof RxJS.distinct;
        distinctUntilChanged: typeof RxJS.distinctUntilChanged;
        distinctUntilKeyChanged: typeof RxJS.distinctUntilKeyChanged;
        elementAt: typeof RxJS.elementAt;
        endWith: typeof RxJS.endWith;
        every: typeof RxJS.every;
        exhaust: typeof RxJS.exhaustAll;
        exhaustAll: typeof RxJS.exhaustAll;
        exhaustMap: typeof RxJS.exhaustMap;
        expand: typeof RxJS.expand;
        filter: typeof RxJS.filter;
        finalize: typeof RxJS.finalize;
        find: typeof RxJS.find;
        findIndex: typeof RxJS.findIndex;
        first: typeof RxJS.first;
        groupBy: typeof RxJS.groupBy;
        ignoreElements: typeof RxJS.ignoreElements;
        isEmpty: typeof RxJS.isEmpty;
        last: typeof RxJS.last;
        map: typeof RxJS.map;
        mapTo: typeof RxJS.mapTo;
        materialize: typeof RxJS.materialize;
        max: typeof RxJS.max;
        merge: typeof RxJSOperators.merge;
        mergeAll: typeof RxJS.mergeAll;
        flatMap: typeof RxJS.mergeMap;
        mergeMap: typeof RxJS.mergeMap;
        mergeMapTo: typeof RxJS.mergeMapTo;
        mergeScan: typeof RxJS.mergeScan;
        mergeWith: typeof RxJS.mergeWith;
        min: typeof RxJS.min;
        multicast: typeof RxJS.multicast;
        observeOn: typeof RxJS.observeOn;
        onErrorResumeNext: typeof RxJS.onErrorResumeNextWith;
        pairwise: typeof RxJS.pairwise;
        partition: typeof RxJSOperators.partition;
        pluck: typeof RxJS.pluck;
        publish: typeof RxJS.publish;
        publishBehavior: typeof RxJS.publishBehavior;
        publishLast: typeof RxJS.publishLast;
        publishReplay: typeof RxJS.publishReplay;
        race: typeof RxJSOperators.race;
        raceWith: typeof RxJS.raceWith;
        reduce: typeof RxJS.reduce;
        repeat: typeof RxJS.repeat;
        repeatWhen: typeof RxJS.repeatWhen;
        retry: typeof RxJS.retry;
        retryWhen: typeof RxJS.retryWhen;
        refCount: typeof RxJS.refCount;
        sample: typeof RxJS.sample;
        sampleTime: typeof RxJS.sampleTime;
        scan: typeof RxJS.scan;
        sequenceEqual: typeof RxJS.sequenceEqual;
        share: typeof RxJS.share;
        shareReplay: typeof RxJS.shareReplay;
        single: typeof RxJS.single;
        skip: typeof RxJS.skip;
        skipLast: typeof RxJS.skipLast;
        skipUntil: typeof RxJS.skipUntil;
        skipWhile: typeof RxJS.skipWhile;
        startWith: typeof RxJS.startWith;
        subscribeOn: typeof RxJS.subscribeOn;
        switchAll: typeof RxJS.switchAll;
        switchMap: typeof RxJS.switchMap;
        switchMapTo: typeof RxJS.switchMapTo;
        switchScan: typeof RxJS.switchScan;
        take: typeof RxJS.take;
        takeLast: typeof RxJS.takeLast;
        takeUntil: typeof RxJS.takeUntil;
        takeWhile: typeof RxJS.takeWhile;
        tap: typeof RxJS.tap;
        throttle: typeof RxJS.throttle;
        throttleTime: typeof RxJS.throttleTime;
        throwIfEmpty: typeof RxJS.throwIfEmpty;
        timeInterval: typeof RxJS.timeInterval;
        timeout: typeof RxJS.timeout;
        timeoutWith: typeof RxJS.timeoutWith;
        timestamp: typeof RxJS.timestamp;
        toArray: typeof RxJS.toArray;
        window: typeof RxJS.window;
        windowCount: typeof RxJS.windowCount;
        windowTime: typeof RxJS.windowTime;
        windowToggle: typeof RxJS.windowToggle;
        windowWhen: typeof RxJS.windowWhen;
        withLatestFrom: typeof RxJS.withLatestFrom;
        zip: typeof RxJSOperators.zip;
        zipAll: typeof RxJS.zipAll;
        zipWith: typeof RxJS.zipWith;
        Observable: typeof RxJS.Observable;
        ConnectableObservable: typeof RxJS.ConnectableObservable;
        observable: string | symbol;
        animationFrames: typeof RxJS.animationFrames;
        Subject: typeof RxJS.Subject;
        BehaviorSubject: typeof RxJS.BehaviorSubject;
        ReplaySubject: typeof RxJS.ReplaySubject;
        AsyncSubject: typeof RxJS.AsyncSubject;
        asap: import("rxjs/internal/scheduler/AsapScheduler").AsapScheduler;
        asapScheduler: import("rxjs/internal/scheduler/AsapScheduler").AsapScheduler;
        async: import("rxjs/internal/scheduler/AsyncScheduler").AsyncScheduler;
        asyncScheduler: import("rxjs/internal/scheduler/AsyncScheduler").AsyncScheduler;
        queue: import("rxjs/internal/scheduler/QueueScheduler").QueueScheduler;
        queueScheduler: import("rxjs/internal/scheduler/QueueScheduler").QueueScheduler;
        animationFrame: import("rxjs/internal/scheduler/AnimationFrameScheduler").AnimationFrameScheduler;
        animationFrameScheduler: import("rxjs/internal/scheduler/AnimationFrameScheduler").AnimationFrameScheduler;
        VirtualTimeScheduler: typeof RxJS.VirtualTimeScheduler;
        VirtualAction: typeof RxJS.VirtualAction;
        Scheduler: typeof RxJS.Scheduler;
        Subscription: typeof RxJS.Subscription;
        Subscriber: typeof RxJS.Subscriber;
        Notification: typeof RxJS.Notification;
        NotificationKind: typeof RxJS.NotificationKind;
        pipe: typeof RxJS.pipe;
        noop: typeof RxJS.noop;
        identity: typeof RxJS.identity;
        isObservable: typeof RxJS.isObservable;
        lastValueFrom: typeof RxJS.lastValueFrom;
        firstValueFrom: typeof RxJS.firstValueFrom;
        ArgumentOutOfRangeError: import("rxjs/internal/util/ArgumentOutOfRangeError").ArgumentOutOfRangeErrorCtor;
        EmptyError: import("rxjs/internal/util/EmptyError").EmptyErrorCtor;
        NotFoundError: import("rxjs/internal/util/NotFoundError").NotFoundErrorCtor;
        ObjectUnsubscribedError: import("rxjs/internal/util/ObjectUnsubscribedError").ObjectUnsubscribedErrorCtor;
        SequenceError: import("rxjs/internal/util/SequenceError").SequenceErrorCtor;
        TimeoutError: import("rxjs/internal/operators/timeout").TimeoutErrorCtor;
        UnsubscriptionError: import("rxjs/internal/util/UnsubscriptionError").UnsubscriptionErrorCtor;
        bindCallback: typeof RxJS.bindCallback;
        bindNodeCallback: typeof RxJS.bindNodeCallback;
        connectable: typeof RxJS.connectable;
        defer: typeof RxJS.defer;
        empty: typeof RxJS.empty;
        forkJoin: typeof RxJS.forkJoin;
        from: typeof RxJS.from;
        fromEvent: typeof RxJS.fromEvent;
        fromEventPattern: typeof RxJS.fromEventPattern;
        generate: typeof RxJS.generate;
        iif: typeof RxJS.iif;
        interval: typeof RxJS.interval;
        never: typeof RxJS.never;
        of: typeof RxJS.of;
        pairs: typeof RxJS.pairs;
        range: typeof RxJS.range;
        throwError: typeof RxJS.throwError;
        timer: typeof RxJS.timer;
        using: typeof RxJS.using;
        scheduled: typeof RxJS.scheduled;
        EMPTY: RxJS.Observable<never>;
        NEVER: RxJS.Observable<never>;
        config: RxJS.GlobalConfig;
        onErrorResumeNextWith: typeof RxJS.onErrorResumeNextWith;
    };
    registerPopoverComponent(popoverComponent: TbPopoverComponent): void;
    updatePopoverPositions(): void;
    setPopoversHidden(hidden: boolean): void;
    registerLabelPattern(label: string, label$: Observable<string>): Observable<string>;
    updateLabelPatterns(): void;
    showSuccessToast(message: string, duration?: number, verticalPosition?: NotificationVerticalPosition, horizontalPosition?: NotificationHorizontalPosition, target?: string, modern?: boolean): void;
    showInfoToast(message: string, verticalPosition?: NotificationVerticalPosition, horizontalPosition?: NotificationHorizontalPosition, target?: string, modern?: boolean): void;
    showWarnToast(message: string, verticalPosition?: NotificationVerticalPosition, horizontalPosition?: NotificationHorizontalPosition, target?: string, modern?: boolean): void;
    showErrorToast(message: string, verticalPosition?: NotificationVerticalPosition, horizontalPosition?: NotificationHorizontalPosition, target?: string, modern?: boolean): void;
    showToast(type: NotificationType, message: string, duration: number, verticalPosition?: NotificationVerticalPosition, horizontalPosition?: NotificationHorizontalPosition, target?: string, modern?: boolean): void;
    hideToast(target?: string): void;
    detectChanges(updateWidgetParams?: boolean): void;
    detectContainerChanges(): void;
    updateWidgetParams(): void;
    updateAliases(aliasIds?: Array<string>): void;
    reset(): void;
    destroy(): void;
    closeDialog(resultData?: any): void;
    pageLink(pageSize: number, page?: number, textSearch?: string, sortOrder?: SortOrder): PageLink;
    timePageLink(startTime: number, endTime: number, pageSize: number, page?: number, textSearch?: string, sortOrder?: SortOrder): TimePageLink;
    alarmQuery(entityId: EntityId, pageLink: TimePageLink, searchStatus: AlarmSearchStatus, status: AlarmStatus, fetchOriginator: boolean, assigneeId: UserId): AlarmQuery;
}
export declare class LabelVariablePattern {
    private ctx;
    private pattern;
    private hasVariables;
    private labelSubject;
    label$: RxJS.Observable<string>;
    constructor(label: string, ctx: WidgetContext);
    setupPattern(label: string): void;
    update(): void;
    destroy(): void;
}
export declare const widgetContextToken: InjectionToken<WidgetContext>;
export declare const widgetErrorMessagesToken: InjectionToken<string[]>;
export declare const widgetTitlePanelToken: InjectionToken<TemplateRef<any>>;
export interface IDynamicWidgetComponent {
    readonly ctx: WidgetContext;
    readonly errorMessages: string[];
    readonly $injector: Injector;
    executingRpcRequest: boolean;
    rpcEnabled: boolean;
    rpcErrorText: string;
    rpcRejection: HttpErrorResponse | Error;
    raf: RafService;
    [key: string]: any;
}
export interface WidgetInfo extends WidgetTypeDescriptor, WidgetControllerDescriptor, ExportableEntity<WidgetTypeId> {
    widgetName: string;
    fullFqn: string;
    deprecated: boolean;
    scada: boolean;
    typeSettingsForm?: FormProperty[];
    typeDataKeySettingsForm?: FormProperty[];
    typeLatestDataKeySettingsForm?: FormProperty[];
    image?: string;
    description?: string;
    tags?: string[];
    componentType?: Type<IDynamicWidgetComponent>;
}
export interface WidgetConfigComponentData {
    widgetName: string;
    config: WidgetConfig;
    layout: WidgetLayout;
    widgetType: widgetType;
    typeParameters: WidgetTypeParameters;
    actionSources: {
        [actionSourceId: string]: WidgetActionSource;
    };
    isDataEnabled: boolean;
    settingsForm: FormProperty[];
    dataKeySettingsForm: FormProperty[];
    latestDataKeySettingsForm: FormProperty[];
    dataKeySettingsFunction: DataKeySettingsFunction;
    settingsDirective: string;
    dataKeySettingsDirective: string;
    latestDataKeySettingsDirective: string;
    hasBasicMode: boolean;
    basicModeDirective: string;
}
export declare const MissingWidgetType: WidgetInfo;
export declare const ErrorWidgetType: WidgetInfo;
export interface WidgetTypeInstance {
    getSettingsForm?: () => FormProperty[];
    getDataKeySettingsForm?: () => FormProperty[];
    getLatestDataKeySettingsForm?: () => FormProperty[];
    typeParameters?: () => WidgetTypeParameters;
    useCustomDatasources?: () => boolean;
    actionSources?: () => {
        [actionSourceId: string]: WidgetActionSource;
    };
    onInit?: () => void;
    onDataUpdated?: () => void;
    onLatestDataUpdated?: () => void;
    onResize?: () => void;
    onEditModeChanged?: () => void;
    onMobileModeChanged?: () => void;
    onDestroy?: () => void;
}
export declare const toWidgetInfo: (widgetTypeEntity: WidgetType) => WidgetInfo;
export declare const detailsToWidgetInfo: (widgetTypeDetailsEntity: WidgetTypeDetails) => WidgetInfo;
export declare const toWidgetType: (widgetInfo: WidgetInfo, id: WidgetTypeId, tenantId: TenantId, createdTime: number, version: number) => WidgetType;
export declare const toWidgetTypeDetails: (widgetInfo: WidgetInfo, id: WidgetTypeId, tenantId: TenantId, createdTime: number, version: number) => WidgetTypeDetails;
export declare const updateEntityParams: (params: StateParams, targetEntityParamName?: string, targetEntityId?: EntityId, entityName?: string, entityLabel?: string) => void;
